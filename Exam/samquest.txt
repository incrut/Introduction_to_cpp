1) Which of the targets in the makefile below creates command.o?

command.o : command.c defs.h command.h
    cc -c command.c

This rule specifies that the object file command.o depends on command.c, defs.h, and command.h. 
It uses the cc command to compile command.c into an object file using the -c flag.

To build the command.o target, you can execute the make command with the appropriate target:
make command.o
This will compile command.c and generate the command.o object file.

2) Which of the artifacts are created when running make with that makefile?

When running make with the provided Makefile, the following artifacts (object files and executable) are created:

Object Files:
main.o
kbd.o
command.o
display.o
insert.o
search.o
files.o
utils.o
These object files are compiled from their respective source files.

Executable:
edit

The edit executable is generated by linking the object files together.

To build all the artifacts specified in the Makefile, you can simply run make without any specific target:
make
This will compile all the necessary source files and generate the object files, and then link them to create the edit executable.

3) Imagine that you have a C++ program with a main function and header file. 
All functions used in the main program are either from the standard library or are contained in that header file.

ans: Those two files can be compiled into an object file.

4) about the inheritance

5) int doubleFirst(std::vector<int> l) {
    auto iter = l.begin();
    int a = *iter;
    return 2 * a;
}

Most likely an error is output if no elements in vector.

6) void F2(long long &i) {
    std::cout << "[" << ++i << "]";
    std::cout << "[" << ++i << "]\n";
}
void Flonglong(void){
long long m[]={10, 20, 30, 40};
F2(m[1]);
std::cout << "[" << *m << "][" << *(m+1) << "][" << *(m+2) << "][" << *(m+3)<<"]\n";
}

*m refers to the first element of the m array, which is 10.
*(m+1) refers to the second element of the m array, which was modified by the F2 function, so its updated value is printed.
*(m+2) refers to the third element of the m array, which is 30.
*(m+3) refers to the fourth element of the m array, which is 40.

output: [21][22]
[10][22][30][40]

7) int x[] = {1,2,3,4};
delete x is needed

The delete[] operator is used specifically for dynamically allocated arrays using new[]. 
It is not used for arrays that are declared as local variables or are statically allocated.

In the case of int xp[] = {1, 2, 3, 4};, the array is declared as a local variable and its memory is automatically 
managed by the program. You don't need to manually deallocate the memory in this case. 
The memory for the array will be automatically released when the variable goes out of scope.

The use of delete[] is only necessary when you explicitly allocate memory using new[] or new, as in dynamic memory allocation. 
For arrays declared as local variables or statically allocated arrays, you don't need to use delete[] or delete to deallocate the memory.

8) float *x = new float[10];
delete[]x is needed

9) int main(){int * a; a = new int [3], delete[] a;} - no leakage of memory

int main() {
    int* a;
    a = new int[3];    // Allocate memory for an array of 3 integers

    delete[] a;        // Delete the array of 3 integers

    return 0;
}

10) int main(){int * a; a = new int [3], a = new int[4], delete[] a;} - leakage of memory
int main() {
    int* a;
    a = new int[3];    // Allocate memory for an array of 3 integers
    a = new int[4];    // Allocate memory for a different array of 4 integers

    delete[] a;        // Delete the array of 4 integers

    // Memory allocated for the array of 3 integers is not deleted
}